#! /usr/bin/env python

from StringIO import StringIO

import os.path
import sys
import textwrap
import keyword
import re

import suds.client

VALID_IDENTIFIER_RE                   = re.compile(r"[_A-Za-z][_A-Za-z1-9]*")
VALID_IDENTIFIER_FIRST_LETTER_RE      = re.compile(r"[_A-Za-z]")
VALID_IDENTIFIER_SUBSEQUENT_LETTER_RE = re.compile(r"[_A-Za-z1-9]")

HEADER = '''\
"""SOAP web services generated from:
%(wsdl)s.
"""

from soaplib.core.model.primitive import (
        Any, AnyAsDict, AnyUri, Boolean, Date, DateTime,
        Decimal, Double, Duration, Integer, Float, Mandatory, String
)
from soaplib.core.model.clazz import Array, ClassModel

from soaplib.core.model.base import Null

from soaplib.core.service import soap, DefinitionBase
from soaplib.core.model.enum import Enum

'''

INTERFACE = '''\
class %(name)s(%(bases)s):
    """%(docstring)s"""
'''

SERVICE_INTERFACE_DOCSTRING = '''\
SOAP service ``%(serviceName)s`` with target namespace %(tns)s.
'''

TYPE_INTERFACE_DOCSTRING = '''\
SOAP %(type)s ``{%(namespace)s}%(name)s``
'''

TYPE_MAP = '''\
WSDL_TYPES = {
%(items)s
}


'''

SOAPMETHOD = '''    @soap(%(args)s_returns=%(response)s)'''

METHOD = '''    def %(name)s(self%(args)s):'''

METHOD_DOCSTRING = '''\
        """Parameters:
%(args)s

        Returns: %(response)s
        """\
'''

DEFAULT_RETURN = '''\
        return None

'''

STANDARD_TYPE_NAMESPACES = [
    'http://schemas.xmlsoap.org/soap/encoding/',
    'http://schemas.xmlsoap.org/wsdl/',
    'http://www.w3.org/2001/XMLSchema'
]

SCHEMA_TYPE_MAPPING = {
    None:                   '%(typeName)s',

    'None':                 'Null',

    'boolean':              'Boolean',
    'string':               'String',

    'long':                 'Integer',
    'int':                  'Integer',
    'short':                'Integer',
    'byte':                 'Integer',

    'unsignedLong':         'Integer',
    'unsignedInt':          'Integer',
    'unsignedShort':        'Integer',
    'unsignedByte':         'Integer',

    'positiveInteger':      'Integer',
    'nonPositiveInteger':   'Integer',
    'negativeInteger':      'Integer',
    'nonNegativeInteger':   'Integer',

    'float':                'Float',
    'double':               'Double',

    'decimal':              'Decimal',

    'dateTime':             'DateTime',
    'date':                 'Date',

    'anyURI':               'AnyUri',
    'token':                'String',
    'normalizedString':     'String',

    'base64Binary':         'String',
    'hexBinary':            'String',
}

def formatDocstring(text, indent=4, colwidth=78):
    width = colwidth - indent
    joiner = '\n' + ' ' * indent
    return joiner.join(textwrap.wrap(text, width) + [''])

def typeName(type):
    resolved = type.resolve()
    return resolved.name or ''

def schemaTypeName(type, deps=None):

    resolved = type.resolve()
    name = resolved.name or ''

    schemaType = SCHEMA_TYPE_MAPPING.get(name)
    if schemaType is None: # not a standard type

        # user default
        schemaType = SCHEMA_TYPE_MAPPING[None] 

        # possibly save dependency link
        if deps is not None:
            deps.append(unicode(name))

    required = type.required()
    schemaType = schemaType % dict(typeName=name, required=required)

    if type.unbounded():
        schemaType = "Array(%s)" % schemaType

    return schemaType

def normalizeIdentifier(identifier):
    if not VALID_IDENTIFIER_RE.match(identifier):
        newIdentifierLetters = []
        firstLetter = True
        for letter in identifier:
            if firstLetter:
                if VALID_IDENTIFIER_FIRST_LETTER_RE.match(letter):
                    newIdentifierLetters.append(letter)
                else:
                    newIdentifierLetters.append('_')
                firstLetter = False
            else:
                if VALID_IDENTIFIER_SUBSEQUENT_LETTER_RE.match(letter):
                    newIdentifierLetters.append(letter)
                else:
                    newIdentifierLetters.append('_')
        identifier = ''.join(newIdentifierLetters)

    if keyword.iskeyword(identifier):
        identifier = identifier + '_'

    return identifier

def get_header(url):
    return HEADER % dict(
            wsdl=url,
        )

def get_printed_types(sd_types, standardTypeNamespaces):
    # Types
    typeMap = {}
    typeSeq = []
    typeDeps = {}
    typeAttributes = {}
    typesPrinted = []
    for type_ in sorted(sd_types, key=lambda t: t.resolve().enum()):

        out = []

        resolved = type_.resolve()
        namespaceURL = resolved.namespace()[1]
        if namespaceURL not in standardTypeNamespaces:

            if resolved.enum():
                typeDescription = "enumeration"
            else:
                typeDescription = "complex type"

            # Look for basess
            interfaceBases = []
            if resolved.extension():
                def find(t):
                    for c in t.rawchildren:
                        if c.extension():
                            find(c)
                        if c.ref is not None:
                            interfaceBases.append(c.ref[0])
                find(resolved)

            if not interfaceBases:
                interfaceBases = ['ClassModel']

            rawTypeName = typeName(type_)

            typeInterfaceName = normalizeIdentifier(rawTypeName)

            typeMap[rawTypeName] = typeInterfaceName
            typeSeq.append((rawTypeName, typeInterfaceName,))
            typeAttributes[rawTypeName] = {}


            if resolved.enum():
                out.append("%s = Enum(%s)\n" % (typeInterfaceName,
                        ', '.join("'%s'" % attr[0].name.replace(' ', '_') for attr in type_.children())))

            else:
                out.append(INTERFACE % dict(
                        name=normalizeIdentifier(typeInterfaceName),
                        bases=', '.join(interfaceBases),
                        docstring=formatDocstring(TYPE_INTERFACE_DOCSTRING % dict(
                                type=typeDescription,
                                name=rawTypeName,
                                namespace=namespaceURL,
                            )
                        )
                    ))
                if type_.children():
                    for attr in type_.children():
                        name = attr[0].name.replace(' ', '_')
                        attrTypeName = typeName(attr[0])
                        typeAttributes[rawTypeName][name] = attrTypeName
                        schemaType = schemaTypeName(attr[0], deps=typeDeps.setdefault(unicode(rawTypeName), []))
                        out.append("    %s = %s\n" % (normalizeIdentifier(name), schemaType,))
                else:
                    out.append('    pass\n')

            out.append('\n')

            typesPrinted.append((rawTypeName, ''.join(out)))
    typesPrinted = sortDeps(typesPrinted, typeDeps)
    type_names, typesPrinted = zip(*typesPrinted)
    return typeMap, typeSeq, typeAttributes, typesPrinted, type_names

def get_methods(sd, typeAttributes, removeInputOutputMesssages, type_names, typeMap):
    methods = {}
    for p in sd.ports:
        for m in p[1]:
            methodName = m[0]
            methodArgs = m[1]
            if methodName not in methods:
                methodDef = p[0].method(methodName)

                # XXX: This is discards the namespace part
                if methodDef.soap.output.body.wrapped:

                    inputMessage  = methodDef.soap.input.body.parts[0].element[0]
                    outputMessage = methodDef.soap.output.body.parts[0].element[0]

                    if outputMessage in typeAttributes:
                        if len(typeAttributes[outputMessage]) > 0:
                            response = typeAttributes[outputMessage].values()[0]
                        else:
                            response = "None"
                    else:
                        response = outputMessage

                    # Remove types used as input/output messages
                    if removeInputOutputMesssages:
                        remove = False
                        for idx, t in enumerate(type_names):
                            if t == inputMessage:
                                remove = True
                                break
                        if remove:
                            del type_names[idx]
                            if inputMessage in typeMap:
                                del typeMap[inputMessage]

                        remove = False
                        for idx, t in enumerate(type_names):
                            if t == outputMessage:
                                remove = True
                                break
                        if remove:
                            del type_names[idx]
                            if outputMessage in typeMap:
                                del typeMap[outputMessage]

                else:
                    response = methodDef.soap.output.body.parts[0].element[0]

                methods[methodName] = (response, methodArgs,)
    return methods

def sortDeps(printed, typeDeps):
    """Sort list of complex types based on internal dependencies"""

    printed = list(reversed(printed))

    queue = [item for item in printed if len(typeDeps.get(unicode(item[0]), [])) == 0]
    satisfied = set(queue)
    remaining = [item for item in printed if item not in queue]

    sortedPrinted = []

    while queue:
        item = queue.pop()
        itemTypeName = unicode(item[0])

        sortedPrinted.append(item)
        satisfied.add(itemTypeName)

        for item in remaining:

            remainingItemTypeName = unicode(item[0])

            depsList = typeDeps.get(remainingItemTypeName, [])
            remainingDeps = []
            for dep in depsList:
                if dep not in satisfied:
                    remainingDeps.append(dep)

            typeDeps[remainingItemTypeName] = remainingDeps

            if len(remainingDeps) == 0:
                queue.append(item)
                remaining.remove(item)

    return sortedPrinted

def get_service_interface_header(sd):
    # Main service interface
    return INTERFACE % dict(
            name=normalizeIdentifier(sd.service.name),
            bases=u"DefinitionBase",
            docstring=formatDocstring(SERVICE_INTERFACE_DOCSTRING % dict(
                    serviceName=sd.service.name,
                    tns=sd.wsdl.tns[1],
                )
            )
        )


def get_service_interface(methods, typeMap):
    out = []

    for methodName, (methodReturnType, argList) in sorted(methods.iteritems()):

        methodArgNames = [m[0] for m in argList]

        methodArgDetails = []
        methodArgSpecs = []

        for m in argList:
            argDetail = m[1]

            # for docstring

            methodModifierParts = []

            if not argDetail.required():
                methodModifierParts.append('optional')
            if argDetail.nillable:
                methodModifierParts.append('may be None')

            methodModifiers = ""
            if methodModifierParts:
                methodModifiers = ' (%s)' % ', '.join(methodModifierParts)

            argTypeName = typeName(argDetail)

            methodSpec = "``%s`` -- %s%s" % (
                    argDetail.name,
                    argTypeName,
                    methodModifiers
                )

            methodArgDetails.append(methodSpec)

            # for @soap decorator

            schemaType = schemaTypeName(argDetail)
            methodArgSpecs.append(schemaType)

        # TODO: Probably not aware of array return types
        if methodReturnType not in typeMap and methodReturnType in SCHEMA_TYPE_MAPPING:
            methodReturnType = SCHEMA_TYPE_MAPPING[methodReturnType]

        out.append(SOAPMETHOD % dict(
                args=''.join(arg + ', ' for arg in methodArgSpecs),
                response=methodReturnType,
            ))

        out.append(METHOD % dict(
                name=normalizeIdentifier(methodName),
                args=''.join(', ' + arg for arg in methodArgNames),
            ))

        out.append(METHOD_DOCSTRING % dict(
                args=''.join('\n        ' + arg_det for arg_det in methodArgDetails),
                response=methodReturnType,
            ))

        out.append(DEFAULT_RETURN)

    return '\n'.join(out)

def get_type_map(typeSeq, typeMap):
    return TYPE_MAP % dict(
            items=',\n'.join(["    '%s': %s" % k for k in typeSeq if k[0] in typeMap])
        )

def generate(client, url=None, standardTypeNamespaces=STANDARD_TYPE_NAMESPACES, removeInputOutputMesssages=True):
    """Given a WSDL URL, return a file that could become your interfaces.py
    """

    printed = [] # list of output to be printed

    for sd in client.sd:
        printed.append(get_header(url))

        # sd.types is a list of tuples where the first element is
        # always equal to the second afaik
        sd_types = (t[0] for t in sd.types)
        typeMap, typeSeq, typeAttributes, typesPrinted, type_names = get_printed_types(sd_types, standardTypeNamespaces)
        printed.extend(typesPrinted)

        serviceInterfaceOut = StringIO()
        print >>serviceInterfaceOut, get_service_interface_header(sd)

        methods = get_methods(sd, typeAttributes, removeInputOutputMesssages, type_names, typeMap) # name -> (response type, list of parameters,)
        print >>serviceInterfaceOut, get_service_interface(methods, typeMap)
        printed.append(serviceInterfaceOut.getvalue())

        typeMapOut = get_type_map(typeSeq, typeMap)
        printed.append(typeMapOut)

    return '\n'.join(printed)

def main():
    if len(sys.argv) < 2:
        print "Usage: %s <url>" % sys.argv[0]
        print "The output will be printed to the console"
        return

    if not '://' in sys.argv[1]:
        sys.argv[1] = 'file://' + os.path.abspath(sys.argv[1])

    client = suds.client.Client(sys.argv[1])
    print generate(client, sys.argv[1])

if __name__ == '__main__':
    main()
